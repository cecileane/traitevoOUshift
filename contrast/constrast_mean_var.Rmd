---
title: "Constrast_mean_var"
author: "Qing Yu(Sabrina)"
date: "February 5, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Goal of the study

In this report, our goal is to check the distribution of contrasts and check the correctness of covariance matrix generated by fixed root model. 
```{r, include=FALSE}
library(l1ou)
library(phylolm)
```


# simluation parameters

We used the lizard tree from the `phylolm` package and associated trait data on these lizard
species (just the first trait, which is the first PC axis from a PCA),
to find parameter values that are realistic.
This trait was analyzed to estimate the shifts in trait evolution using the function
`estimate_shift_configuration` from the `l1ou` package. The analysis takes
about 2 minutes, so the results were saved in an R data file:

```{r, eval=FALSE,include=TRUE}

eModel <- estimate_shift_configuration(lizard$tree, lizard$Y)
save(eModel,  file = "eModel_2_5.RData")
```


Next, variables are set up to prepare the simulation.

```{r}
load("eModel_2_17.RData")
data(lizard.tree, lizard.traits)
lizard <- adjust_data(lizard.tree, lizard.traits[,1])
truealpha=eModel$alpha
y0=eModel$intercept
truetheta = y0 + l1ou:::convert_shifts2regions(eModel$tree, 
                                eModel$shift.configuration, eModel$shift.values)
nShifts   = length(eModel$shift.configuration) # Total number of shifts
n_tips=length(eModel$tree$tip.label) # Total number of tips
sigma2=eModel$sigma2
shiftnode= eModel$tree$edge[eModel$shift.configuration,1]-n_tips # internal nodes with shift
othernode=(1:(n_tips-1))[-shiftnode] # Other nodes: those without a true shift
```


The tree has $`r n_tips`$ tips and $`r length(shiftnode)`$ nodes with a shift at one
of its child edges, numbered 
$`r shiftnode`$ (`shiftnode`). At these shifts, the optimal value changed by:
`r round(eModel$shift.values,2)` (shift values).
The other parameters were estimated to be $\alpha=$ $`r truealpha`$ (`truealpha`)
and $\sigma^2=$ $`r sigma2`$
and an "intercept" `y0` of $`r y0`$. Together with the changes, this intercept gives the following 
optimal values `truetheta`, one for each edge:
$\theta=$ `r round(truetheta,2)`.

We used this model to simulate new data using the `rTraitCont` function from the `phylolm` package.
Below, `RE` is the result of the function `sqrt_OU_covariance`, which calculates the square-root of the 
phylogenetic covariance matrix with a recursive algorithm, which traverses the tree once.
`C.IH` is the inverse square root of the phylogenetic covariance matrix, and `C.H` is the square-root of the phylogenetic covariance matrix. 
Finally, `YY` contains the contrasts at all nodes. 
These matrices and contrasts were obtained using the true value of $\alpha$,
the same value used to simulate the data. This is an ideal situation when
$\alpha$ is known without error. 
```{r, include=FALSE}
n_sim=100000
```

# Simulation of Y using `rtraitCont` 

```{r, eval=FALSE, include=TRUE}
n_sim=100000
Y_table=matrix(nrow=n_sim, ncol=n_tips, data=NA)
for (i in 1:n_sim) {
  Y  <- rTraitCont(eModel$tree, "OU", theta=truetheta, 
                 alpha=truealpha, 
                 sigma=sqrt(eModel$sigma2), root.value=y0)
  Y_table[i,]=Y
}
save(Y_table, file="Y_table_2_5.RData")
```
The covariance matrix generated by Y is the same as the covariance matrix generated by fixed root from the definition. 

### Checking whether mu from eModel and mean of tips from Y are significant different

```{r}
load("Y_table_2_27.RData")
truemu=as.matrix(apply(Y_table,2,mean))
#cbind(eModel$mu,truemu)
head(eModel$mu)
head(truemu)
2*sqrt(eModel$sigma2/n_sim) ## 2*standard error
all.equal(eModel$mu,truemu, scale=1)
all.equal(eModel$mu,truemu,tolerance= 2*sqrt(eModel$sigma2/n_sim), scale=1)
```
mu from eModel and mean of tips from Y are not significant different

### Compute the observed covariance matrix of Y
```{r,eval=FALSE}
cov_table=matrix(nrow=n_tips,ncol=n_tips,data=NA)
for (noderow in 1:n_tips){
  for(nodecol in 1:n_tips){
    sum=0
    for(sim in 1:n_sim){
      sum=(Y_table[sim,noderow]-eModel$mu[noderow])*(Y_table[sim,(nodecol)]-eModel$mu[nodecol])+sum
    }
    cov_table[noderow,nodecol]=sum/n_sim
  }
}
save(cov_table,file="Cov_table_2_5.RData")
```


### Calculate the true covariance matrix with fixed root model

```{r}
tij=vcv(lizard.tree)  # the time spent on each edge
treeheight=max(tij)   
dij=2*(treeheight-tij) 
##vrandom=1/(2*truealpha)*exp(-truealpha*dij) # Sigma generated by OUrandomRoot model
vfix=1/(2*truealpha)*exp(-truealpha*dij)*(1-exp(-2*truealpha*tij))
```



### Check agreement between observed and true covariance matrix of Y

```{r}
load("Cov_table_02_05.RData")
# matrix to be compared with
true_cov=vfix*eModel$sigma2
matequal <- function(x, y)
	all(abs(x-y)<=4*sqrt(1/n_sim)*eModel$sigma2*max(diag(vfix)))

matequal(true_cov,cov_table) 
sqrt(1/n_sim)*eModel$sigma2*max(diag(vfix))
all.equal(true_cov,cov_table,scale=1)
all.equal(true_cov,cov_table,scale=1,tolerance=4*sqrt(1/n_sim)*eModel$sigma2*max(diag(vfix)))
true_cov[1:6,1:6]
cov_table[1:6,1:6]
layout(matrix(1:2,1,2))
plot(cov_table,true_cov); abline(a=0, b=1)
hist(cov_table-true_cov)
```
The covariance matrix generated by Y is not significantly different from true covariance matrix of fixed root. 

### square root of covariance matrix 

We first calculate it with `sqrt_OU_covariance`, then check that it is in agreement with
the true covariance `vfix` calculated earlier.

```{r}
REf = sqrt_OU_covariance(lizard.tree, alpha=truealpha, 
                        root.model = "OUfixedRoot",normalize.tree.height = T,
                        check.order=F, check.ultrametric=F)

Dtf  = t(REf$sqrtInvSigma)
Bf   = REf$sqrtSigma
all.equal(Dtf%*%Bf,diag(100), scale=1)
Ind_fix=Dtf%*%vfix%*%t(Dtf)
diag(Ind_fix)
all.equal(Ind_fix,diag(100), scale=1)
```
"sqrt_OU_covariance" function caculates the square root of covariance matrix correctly. 

# Calculate Contrasts

```{r, eval=FALSE, include=TRUE}
contrast_table=matrix(nrow=n_sim, ncol=n_tips, data=NA)
for (i in 1:nrow(Y_table)) {
  contrast_table[i,]=Dtf%*%(Y_table[i,] - eModel$mu)
}
save(contrast_table, file="contrast_table_2_5.RData")
```

###Check whether contrast mean is equal to 0
```{r}
load('contrast_table_2_27.RData')
head(colMeans(contrast_table)) 
max(abs(colMeans(contrast_table)))
colMeans(contrast_table)
```
The mean of all contrasts are all very close to zeros. 

### Check whether contrast variance is equal to sigma2
```{r}
ss=function(x){
  sum(x^2)/length(x)
}
convar=apply(contrast_table,2,ss)
convar
mean(convar)
eModel$sigma2
```
The variance of contrasts is the same as sigma square. 