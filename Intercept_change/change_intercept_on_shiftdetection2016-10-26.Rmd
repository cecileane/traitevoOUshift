---
title: "The Effect of Intercept Changes on Shift Detection"
author: "Cecile Ane and Qing Yu(Sabrina)"
date: "October 25, 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Goal of the study
In this report, we use `Rstudio` with version `r getRversion()` and `l1ou` package with version `r packageVersion("l1ou")`. Our goal is to explore potential changes on the shift detection when the intercept changes. From the [`bs_shift`](https://yuqing19118.github.io/bs_shift_noint2016_09_04.html) report, we can see that the number of false-positives (non-shift edges detected as shift edges) close to the root decreased when we set the intercept to 0. The results here show that the value of the intercept influences the number of shift edges that are detected.


```{r,include=FALSE}
library('phylolm')
library('l1ou')
library(plotrix)
```

I will use here the lizard tree and data from the `l1ou` packages. I used a subset of the 100 species, each time removing 10 species (the last 10, the second-to-last set of 10 or the first 10 species).
For each data subset, I estimated the shift configuration of the original data (results called `eModel`), and then I re-estimated the shift configuration of the data after adding a constant value to all species traits (results called `eModel2`). I used a constant of `400` . In addition, I used three methods to generate the dataset for each subset. It turns out those datasets generated by different methods have the same shift configurations.
1. In the first method, I apply `adjust_data` on lizard tree and trait data and estimate shift configuration on `lizard$tree` combined with `lizard$Y` and on `lizard$tree` combined with `lizard$Y+400`.   
2. In the second method, I did not use `adjust_data` function. Instead, I adjusted the data manually. I reordered the lizard tree into postorder and then normalized the tree into unit tree height.    
3. In the third method, I apply `adjust_data` function separately on the original lizard tree combined with trait and also on the original lizard tree combined with original trait value +400.   

I expected the intercept to change by a value of 400 , and I expected that all other estimated coefficients and parameters would not change. But, they did.

First, I checked the tree and the data had the species listed in the same order: 
```{r}
data(lizard.tree, lizard.traits)
all.equal(names(lizard.traits[,1]),lizard.tree$tip.label)
```

# Analysis of the first 90 species

The function `drop.tip` is used to exclude the last 10 tips on the tree. 


#### The first method to generate data used by estimating shift configuration 


In this case, I adjust lizard tree and trait data into `lizard` which is a list of information including `tree`(lizard tree) and `Y`(trait vector/matrix).
From the result below, `trait1` has just been added as `Y` variable in a list called `lizard` with no changes.

`Adjust_data` function does two things: 1. It reorders the tree edges in postorder so those can match the order of the tree tip labels. 2. It normalizes the branches to a unit tree height. 3. the order of the trait vector/matrix may change according to the order of the tree tip labels.

```{r}
data(lizard.tree, lizard.traits)
tr1=drop.tip(lizard.tree,91:100)
trait1=lizard.traits[,1][-(91:100)]
lizard <- adjust_data(tr1,trait1)
all.equal(trait1, lizard$Y[,1]) 
```

Then, I start to detect shifts on the original and on the translated data (the intercept has change by a value of 400).
```{r, eval=FALSE}
eModel <- estimate_shift_configuration(lizard$tree, lizard$Y)
eModel2 <- estimate_shift_configuration(lizard$tree, lizard$Y+400)
save(eModel, file="eModelint.RData")
save(eModel2, file="eModelint2.RData")
```




#### The second method to generate data used by estimating shift configuration 

I did not use the `adjust_data` function in this dataset.  Instead, I reorder the tree in postorder using function `reorder` and then normalize the tree using `normalize_tree` function to change branch lengths of the tree to a unit tree height. Then, I start to detect shifts on the original and on the translated data (the intercept has change by a value of 400).
```{r, eval=FALSE}
data(lizard.tree, lizard.traits)
tr1=drop.tip(lizard.tree,91:100)
trait1=lizard.traits[,1][-(91:100)]
#lizard <- adjust_data(tr1,trait1)
fittree=reorder(tr1,"postorder")
eModel3 <- estimate_shift_configuration(normalize_tree(fittree), trait1)
eModel4 <- estimate_shift_configuration(normalize_tree(fittree), trait1+400)
save(eModel3, file="eModelint3.RData")
save(eModel4, file="eModelint4.RData")
```

#### The third method to generate data used by estimating shift configuration 

In the method below, I apply `adjust_data` function separately on the original lizard tree combined with trait and also on the original lizard tree combined with orginal trait value +400.
```{r}
data(lizard.tree, lizard.traits)
tr1=drop.tip(lizard.tree,91:100)
trait1=lizard.traits[,1][-(91:100)]
all.equal(names(trait1),tr1$tip.label)
lizard0 <- adjust_data(tr1,trait1)
lizard1 <- adjust_data(tr1,trait1+400)
all.equal(trait1, lizard0$Y[,1]) 
all.equal(trait1+400, lizard1$Y[,1]) 
```

```{r, eval=FALSE}
eModel_c <- estimate_shift_configuration(lizard0$tree, lizard0$Y)
eModel2_c <- estimate_shift_configuration(lizard1$tree, lizard1$Y)
save(eModel_c, file="eModelint1_c.RData")
save(eModel2_c, file="eModelint2_c.RData")
```


The function below returns a list of information about shiftedges for both models and theta values of shiftedges.This function will be used many times to see comparison between two models with or without adding 400.
`Intercept1` represents the intercept of model1.   
`Intercept2` represents the intercept of model2.   
`shiftedge1` represents the shift configuration of model1.   
`shiftedge2` represents the shift configuration of model2.   
`truetheta1` represents the theta values of shift edges from model1.   
`truetheta2` represents the theta values of shift edges from model2.  
```{r}
# A function to generate shift values of shift edges
comparison=function(model1,model2){
  o1 = order(model1$shift.configuration,decreasing = F)
  shiftedge1= model1$shift.configuration[o1]
  o2 = order(model2$shift.configuration,decreasing = F)
  shiftedge2= model2$shift.configuration[o2]
  theta1 = model1$intercept + l1ou:::convert_shifts2regions(model1$tree, 
                                  model1$shift.configuration, model1$shift.values)

  theta2 = model2$intercept + l1ou:::convert_shifts2regions(model2$tree, 
                                model2$shift.configuration, model2$shift.values)
  newList <- list("Intercept1" = model1$intercept,
                  "Alpha1" = model1$alpha,
                  "shiftedge1" = shiftedge1,
                  "theta1" = theta1[shiftedge1][o1],
                  "Intercept2" = model2$intercept,
                  "Alpha2" = model2$alpha,
                  "shiftedge2" = shiftedge2,
                  "theta2" = theta2[shiftedge2][o2]
                  )
return(newList)
}
```



The function below returns a plot of a subset of the lizard tree. The shift edges are marked as blue for plot of the original data and purple for plot of the translated data.  
```{r} 
plotshiftedge=function(model1,model2){
shiftedge1=sort(model1$shift.configuration,decreasing = F)
shiftedge2=sort(model2$shift.configuration,decreasing = F)
layout(matrix(1:2, 1, 2))
plot(eModel$tree,show.tip.label = F,main="original data",font=8)
edgelabels(shiftedge1,shiftedge1,col="blue",frame="none")
plot(eModel2$tree,show.tip.label = F,main="original data + 400",font=8)
edgelabels(shiftedge2,shiftedge2,col="purple",frame="none")
}
```


# See results
Now that we estimated the models on the original and on
the translated data, let's check to see if the shift edges for two models are the same or not.

Results from the dataset generated using the first method
```{r myplot1,echo=TRUE, fig.width=8, fig.height=12,dpi=300} 
load('eModelint.RData')
load('eModelint2.RData')
all.equal(sort(eModel$shift.configuration),sort(eModel2$shift.configuration))
comparison(eModel,eModel2)
plotshiftedge(eModel,eModel2)
```
From the list of information, I can see intercept for `eModel2` is exactly equal to the intercept of `eModel` added by 400. Shift configurations of both models are the same. And the theta values of shiftedges from `eModel2` are exactly equal to the theta values of shiftedges from `eModel` added by 400. 


Results from the dataset generated using the second method
```{r}
load('eModelint3.RData')
load('eModelint4.RData')
all.equal(sort(eModel3$shift.configuration),sort(eModel4$shift.configuration))
comparison(eModel3,eModel4)
```
the information in this section is exactly the same as the information from the last section. 


Results from the dataset generated using the third method
```{r}
load('eModelint1_c.RData')
load('eModelint2_c.RData')
all.equal(sort(eModel_c$shift.configuration),sort(eModel2_c$shift.configuration))
comparison(eModel_c,eModel2_c)
```
The information in this section is exactly the same as the information from the last section. 

Lastly, I checked that `eModel`s of the three translated data generated by three methods are the same.
```{r}
all.equal(eModel2_c$Y,eModel4$Y,eModel2$Y)
all.equal(eModel2_c$shift.values,eModel4$shift.values,eModel2$shift.values)
all.equal(eModel2_c$alpha,eModel4$alpha,eModel2$alpha)
all.equal(eModel2_c$optima,eModel4$optima,eModel2$optima)
```

# Analysis of the second data subset which excludes the second-to-last set of 10 species

like before, I first extracted one data subset.
I do not include the 81st to 90th tips on the tree

#### The first method to generate data used by estimating shift configuration 
```{r}
data(lizard.tree, lizard.traits)
tr2=drop.tip(lizard.tree,81:90)
trait2=lizard.traits[,1][-(81:90)]
all.equal(names(trait2),tr2$tip.label)
lizard <- adjust_data(tr2,trait2)
all.equal(trait2, lizard$Y[,1]) 
```


Then, I start to detect shifts on the original and on the translated data (the intercept has changed by a value of 400).

```{r, eval=FALSE}
eModel <- estimate_shift_configuration(lizard$tree, lizard$Y)
eModel2 <- estimate_shift_configuration(lizard$tree, lizard$Y+400)
save(eModel, file="eModelint21.RData")
save(eModel2, file="eModelint22.RData")
```

#### The second method to generate data used by estimating shift configuration 
```{r, eval=FALSE}
data(lizard.tree, lizard.traits)
tr2=drop.tip(lizard.tree,81:90)
trait2=lizard.traits[,1][-(81:90)]
#lizard <- adjust_data(tr1,trait1)
fittree=reorder(tr2,"postorder")
eModel3 <- estimate_shift_configuration(normalize_tree(fittree), trait2)
eModel4 <- estimate_shift_configuration(normalize_tree(fittree), trait2+400)
save(eModel3, file="eModelint32.RData")
save(eModel4, file="eModelint42.RData")
```

#### The third method to generate data used by estimating shift configuration 

```{r, eval=FALSE}
data(lizard.tree, lizard.traits)
tr2=drop.tip(lizard.tree,81:90)
trait2=lizard.traits[,1][-(81:90)]
all.equal(names(trait2),tr2$tip.label)
lizard0 <- adjust_data(tr2,trait2)
lizard1 <- adjust_data(tr2,trait2+400)
eModel_c <- estimate_shift_configuration(lizard0$tree, lizard0$Y)
eModel2_c <- estimate_shift_configuration(lizard1$tree, lizard1$Y)
save(eModel_c, file="eModelint21_c.RData")
save(eModel2_c, file="eModelint22_c.RData")
```
I try to compare if the shift edges detected from the original data set are different from the translated data set.

# See results
Results from the dataset generated using the first method
```{r myplot2,echo=TRUE, fig.width=8, fig.height=12,dpi=300} 
load('eModelint21.RData')
load('eModelint22.RData')
all.equal(sort(eModel$shift.configuration),sort(eModel2$shift.configuration))
comparison(eModel,eModel2)
plotshiftedge(eModel,eModel2)
```
From the list of information, the intercept for `eModel2` is close but not equal to the intercept of `eModel` added by 400. Shift configurations of both models are different. The translated data has fewer shifts detected. Those shifts being detected from the translated data have relatively high theta values compared to theta values of other shift edges from `eModel`. And the theta values of shiftedges from `eModel2` is much different from the theta values of shiftedges from `eModel` added by 400. 

Results from the dataset generated using the second method
```{r}
load('eModelint32.RData')
load('eModelint42.RData')
all.equal(sort(eModel3$shift.configuration),sort(eModel4$shift.configuration))
comparison(eModel3,eModel4)
```
The information in this section is exactly the same as the information from the last section. 


Results from the dataset generated using the third method
```{r}
load('eModelint21_c.RData')
load('eModelint22_c.RData')
all.equal(sort(eModel_c$shift.configuration),sort(eModel2_c$shift.configuration))
comparison(eModel_c,eModel2_c)
```

The information in this section is exactly the same as the information from the last section. 

In general, I checked the `eModel`s generated by three methods are the same.
```{r}
all.equal(eModel2_c$Y,eModel4$Y,eModel2$Y)
all.equal(eModel2_c$shift.values,eModel4$shift.values,eModel2$shift.values)
all.equal(eModel2_c$alpha,eModel4$alpha,eModel2$alpha)
all.equal(eModel2_c$optima,eModel4$optima,eModel2$optima)
```

# Analysis of the third data subset which excludes the first 10 species

# Generating data for the third sample.
In this case, I do not include the first 10 tips on the tree.The `eModel` and `eModel2` are identical besides their intercepts. I try to compare if the shftedges detected by the two models are different or not. 

#### The first method to generate data used by estimating shift configuration
```{r, eval=FALSE}
data(lizard.tree, lizard.traits)
tr3=drop.tip(lizard.tree,1:10)
trait3=lizard.traits[,1][11:100]
all.equal(names(trait3),tr3$tip.label)
lizard <- adjust_data(tr3,trait3)
all.equal(names(trait3),row.names(lizard$Y))
all.equal(trait3,lizard$Y[,1]) #Exactly the same
eModel <- estimate_shift_configuration(lizard$tree, lizard$Y)
eModel2 <- estimate_shift_configuration(lizard$tree, lizard$Y+400)
save(eModel, file="eModelint51.RData")
save(eModel2, file="eModelint52.RData")
```

#### The second method to generate data used by estimating shift configuration
```{r, eval=FALSE}
data(lizard.tree, lizard.traits)
tr3=drop.tip(lizard.tree,1:10)
trait3=lizard.traits[,1][11:100]
#lizard <- adjust_data(tr1,trait1)
fittree=reorder(tr3,"postorder")
eModel3 <- estimate_shift_configuration(normalize_tree(fittree), trait3)
eModel4 <- estimate_shift_configuration(normalize_tree(fittree), trait3+400)
save(eModel3, file="eModelint33.RData")
save(eModel4, file="eModelint43.RData")
```


#### The third method to generate data used by estimating shift configuration
```{r, eval=FALSE}
data(lizard.tree, lizard.traits)
tr3=drop.tip(lizard.tree,1:10)
trait3=lizard.traits[,1][11:100]
lizard0 <- adjust_data(tr3,trait3)
lizard1 <- adjust_data(tr3,trait3+400)
eModel_c <- estimate_shift_configuration(lizard0$tree, lizard0$Y)
eModel2_c <- estimate_shift_configuration(lizard1$tree, lizard1$Y)
save(eModel_c, file="eModelint31_c.RData")
save(eModel2_c, file="eModelint32_c.RData")
```

# See results

The shift edges that has been detected from the two models are not the same.There are fewer shift edges that have been detected for `eModel2` which has a higher intercept. 

Results from the dataset generated using the first method
```{r myplot3,echo=TRUE, fig.width=8, fig.height=12,dpi=300} 
load('eModelint51.RData')
load('eModelint52.RData')
all.equal(sort(eModel$shift.configuration),sort(eModel2$shift.configuration))
comparison(eModel,eModel2)
plotshiftedge(eModel,eModel2)
```

From the list of information, the intercept for `eModel2` is close but not equal to the intercept of `eModel` added by 400. Shift configurations of both models are different. The translated data has fewer shifts detected. Those shifts being detected from the translated data have relatively high theta values compared to theta values of other shift edges from the original data. And the theta values of shiftedges from `eModel2` is much different from the theta values of shiftedges from `eModel` added by 400. 


Results from the dataset generated using the second method
```{r}
load('eModelint33.RData')
load('eModelint43.RData')
all.equal(sort(eModel3$shift.configuration),sort(eModel4$shift.configuration))
comparison(eModel3,eModel4)
```
The information in this section is exactly the same as the information from the last section. 


Results from the dataset generated using the third method
```{r}
load('eModelint31_c.RData')
load('eModelint32_c.RData')
all.equal(sort(eModel_c$shift.configuration),sort(eModel2_c$shift.configuration))
comparison(eModel_c,eModel2_c)
```
The information in this section is exactly the same as the information from the last section. 

In general, I checked the `eModel`s generated by three methods are the same.
```{r}
all.equal(eModel2_c$Y,eModel4$Y,eModel2$Y)
all.equal(eModel2_c$shift.values,eModel4$shift.values,eModel2$shift.values)
all.equal(eModel2_c$alpha,eModel4$alpha,eModel2$alpha)
all.equal(eModel2_c$optima,eModel4$optima,eModel2$optima)
```
